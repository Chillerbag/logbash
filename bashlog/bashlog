#!/bin/bash

# TODOS:
# 1) add more error handling
# 2) make functions reference local vars, not $1 etc. 
# 5) variablr names are all over the place. fix.
# make pretty! (code wise)


new_log() {
  DATA_DIR="$HOME/.local/share/bashlog/${1}_bashlog.csv"
  mkdir -p "$(dirname "${DATA_DIR}")"

  if [[ -f "${DATA_DIR}" ]]; then
    echo "Error, log with that name already exists at: ${DATA_DIR}"
    exit 1
  fi

  touch "${DATA_DIR}" || {
    echo "Error, could not create log at ${DATA_DIR}"
    exit 1
  }

  echo "Log made successfully at ${DATA_DIR}"
}

read_log() {
  DATA_DIR="$HOME/.local/share/bashlog/${1}_bashlog.csv"

  if [[ ! -f "${DATA_DIR}" ]]; then
    echo "Error, there is no log with that name: ${DATA_DIR}"
    exit 1
  fi

  # there has to be a better way than this. 
  width=$(tput cols)
  length=$((${#1} + 2))
  number=$(( ($RANDOM % 7) + 1 ))
  border=$(printf =%"${length}"s= | tr " " "=")
  tput setaf ${number}
  tput hpa $(((width / 2) - (length / 2)))
  echo "${border}"
  tput hpa $(((width / 2) - (length / 2)))
  echo "= ${1} = "
  tput hpa $(((width / 2) - (length / 2)))
  echo "${border}"
  tput setaf 9

  nl -s ') ' "${DATA_DIR}" | while read -r line; do
    tput hpa $(((width / 2) - (length / 2)))
    tput setaf ${number}
    echo -n "| "
    tput setaf 9
    echo "${line}"
  done
}

update_log() {
  DATA_DIR="$HOME/.local/share/bashlog/${1}_bashlog.csv"

  if [[ ! -f "${DATA_DIR}" ]]; then
    echo "Error, there is no log with that name: ${DATA_DIR}"
    exit 1
  fi

  sed -i -e '$a\' "${DATA_DIR}"
  
  first_line=$(head -n 1 "${DATA_DIR}")
  echo "Completing ${first_line}"
  read -p "Continue? (y/n) " confirm

  if [[ "${confirm}" == "y" ]]; then
    sed -i '1d' "${DATA_DIR}"
    echo "Completed!" 
  else
    echo "Cancelled"
  fi 
}

delete_log() {
  DATA_DIR="$HOME/.local/share/bashlog/${1}_bashlog.csv"

  if [[ ! -f "${DATA_DIR}" ]]; then
    echo "Error, there is no log with that name: ${DATA_DIR}"
    exit 1
  else
    rm "${DATA_DIR}"
    echo "Log has been successfully deleted."
  fi

}

add_to_log() {
    LOG="${1}"
    DATA_DIR="$HOME/.local/share/bashlog/${LOG}_bashlog.csv"
    NEW_ENTRY="${2}" 

    if [[ ! -f "${DATA_DIR}" ]]; then
      echo "Error, there is no log with that name: ${DATA_DIR}"
      exit 1
    fi 

    if [[ -s "${DATA_DIR}" ]] && [[ $(tail -c1 "${DATA_DIR}" | wc -l) -eq 0 ]]; then
        echo >> "${DATA_DIR}"
    fi
    
    echo "${NEW_ENTRY}" >> "${DATA_DIR}" 

    echo "${NEW_ENTRY} has been added to log ${LOG}"

}

swap_records() {
  local log="${1}"
  local l1="${2}"
  local l2="${3}"

  DIR="$HOME/.local/share/bashlog/${log}_bashlog.csv"
  if [[ ! -f "${DIR}" ]]; then
    echo "Error, there is no log with that name: ${DIR}"
    exit 1
  fi 

  # TODO: error handle reading these lines 
  line1_content=$(sed -n "${l1}p" "$DIR") # p = print -n = no print to console
  line2_content=$(sed -n "${l2}p" "$DIR")

  # swap the lines 
  sed -i.bak \
    -e "${l1}s/.*/${line2_content}/" \
    -e "${l2}s/.*/${line1_content}/" \
    "${DIR}"

  rm "${DIR}.bak"
  echo "Swap has completed successfully."
}

print_logs() {
  local dir="$HOME/.local/share/bashlog/"
  local title="Logs"
  width=$(tput cols)
  #yourfilenames=$(ls ${dir}*_bashlog.csv) # add to notes - command variable substituion
  #echo "${yourfilenames}"
  length=$((${#title} + 2))
  number=$(( ($RANDOM % 7) + 1 ))
  border=$(printf =%"${length}"s= | tr " " "=")
  tput setaf ${number}
  tput hpa $(((width / 2) - (length / 2)))
  echo "${border}"
  tput hpa $(((width / 2) - (length / 2)))
  echo "= ${title} = "
  tput hpa $(((width / 2) - (length / 2)))
  echo "${border}"
  tput setaf 9
  for file in ${dir}*_bashlog.csv; do
    tput hpa $(((width / 2) - (length / 2)))
    tput setaf ${number}
    echo -n "| "
    tput setaf 9
    echo "$(basename "${file}" _bashlog.csv)" # add to notes
  done
}

main() {
  while getopts "n:r:u:a:d:s:hl" flag; do
    case $flag in
      n)
        log="${OPTARG}"
        new_log "${log}"
        # TODO: Should return and evaluate a code here. google standard
        ;;
      r)
        log_to_read="${OPTARG}"
        read_log "${log_to_read}"
        ;;
      u)
        log_to_update="${OPTARG}"
        update_log "${log_to_update}"
        read_log "${log_to_update}"

        ;;
      a)
        log_to_add="${OPTARG}"
        log_to_update="${!OPTIND}"
        # maybe shift here to remove positional arg. 
        add_to_log "${log_to_add}" "${log_to_update}"
        read_log "${log_to_add}"
        ;;
      d)
        log_to_delete="${OPTARG}"
        delete_log "${log_to_delete}"
        ;;
      l) 
        print_logs
        ;;
      s) 
        log_to_swap="${OPTARG}"
        l1="${!OPTIND}"
        # is this good syntax? ask online. 
        OPTIND=$((OPTIND + 1))
        l2="${!OPTIND}"
        swap_records "${log_to_swap}" "${l1}" "${l2}"
        read_log "${log_to_swap}"
        ;;
      h)
        echo "Usage: ${0} [-n Maker a new log] [-r Read a log] [-u Log to update] [-a (Log to add to) (New item)] [-d Delete a log] [-l List all logs] [-s log line1 line2] [-h]"
        ;;
      ?)
        echo "Invalid option: -${OPTARG}"
        exit 1
        ;;
    esac
  done 
}

main "$@" 
      
      
    

    